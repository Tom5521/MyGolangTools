# MyGolangTools

- [MyGolangTools](#mygolangtools)
  * [Documentation for the "commands" library in Golang](#documentation-for-the--commands--library-in-golang)
    + [Description](#description)
    + [Basic Usage](#basic-usage)
    + [Methods](#methods)
      - [1. `Cmd(input string) error`](#1--cmd-input-string--error-)
      - [2. `Out(input string) (string, error)`](#2--out-input-string---string--error--)
    + [Advanced Configuration](#advanced-configuration)
      - [1. Shell Configuration](#1-shell-configuration)
      - [2. Custom Shell Configuration on Linux](#2-custom-shell-configuration-on-linux)
      - [3. Custom Standard I/O Configuration](#3-custom-standard-i-o-configuration)
    + [Full Example](#full-example)
  * [Documentation for the "file" library in Golang](#documentation-for-the--file--library-in-golang)
    + [Import](#import)
    + [Function `CheckFile(file string) (bool, error)`](#function--checkfile-file-string---bool--error--)
    + [Function `ReadFileCont(file string) ([]byte, error)`](#function--readfilecont-file-string-----byte--error--)
    + [Function `ReWriteFile(file, text string) error`](#function--rewritefile-file--text-string--error-)
    + [Function `GetBinaryDir() (string, error)`](#function--getbinarydir----string--error--)

## Documentation for the "commands" library in Golang


<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>

### Description

The "commands" library provides a simple interface for executing commands on Windows and Linux operating systems from a Golang application. The library handles the selection of the appropriate shell based on the operating system and allows customization of standard input and output options.

### Basic Usage

1. Import the library into your Golang program:

```go
package main

import "github.com/Tom5521/MyGolangTools/commands" 
```

2. Create an instance of the `Sh` struct to use the provided methods:

```go
sh := commands.Sh{}
```

### Methods

#### 1. `Cmd(input string) error`

The `Cmd` method is used to execute a command in the selected shell based on the operating system.

Parameters:
- `input` (string): The command to be executed.

Return:
- `error`: If there is an error during command execution.

Example usage:

```go
sh.Windows.PowerShell = true // Use PowerShell on Windows
err := sh.Cmd("ls -l")
if err != nil {
    fmt.Println("Error executing the command:", err)
}
```

#### 2. `Out(input string) (string, error)`

The `Out` method is used to execute a command in the selected shell and capture its output.

Parameters:
- `input` (string): The command to be executed.

Return:
- `string`: The output generated by the command.
- `error`: If there is an error during command execution.

Example usage:

```go
sh.Windows.PowerShell = false // Use cmd shell on Windows
out, err := sh.Out("echo 'Hello, world!'")
if err != nil {
    fmt.Println("Error executing the command:", err)
} else {
    fmt.Println("Command output:", out)
}
```

### Advanced Configuration

The "commands" library allows you to configure some advanced options for customizing command execution:

#### 1. Shell Configuration

You can specify the shell to be used on Windows and Linux using the `Windows.PowerShell` and `Linux.Bash` fields, respectively.

Example:

```go
sh.Windows.PowerShell = true // Use PowerShell on Windows
sh.Linux.Bash = true // Use Bash on Linux
```

#### 2. Custom Shell Configuration on Linux

On Linux systems, you can enable a custom shell and specify its name and arguments using the `Linux.CustomSh` field.

Example:

```go
sh.Linux.CustomSh.Enable = true
sh.Linux.CustomSh.ShName = "/usr/bin/zsh"
sh.Linux.CustomSh.ShArg = "-c"
```

#### 3. Custom Standard I/O Configuration

You can customize standard input and output options for commands using the `CustomStd` field.

Example:

```go
sh.CustomStd.Enable = true
sh.CustomStd.Stdin = true // Enable standard input
sh.CustomStd.Stdout = true // Enable standard output
sh.CustomStd.Stderr = true // Enable standard error output
```

### Full Example

Here's a complete example of how to use the "commands" library with different configurations:

```go
package main

import (
	"fmt"
    "github.com/Tom5521/MyGolangTools/commands"		
)

func main() {
	sh := commands.Sh{}

	sh.Windows.PowerShell = true // Use PowerShell on Windows
	err := sh.Cmd("ls -l")
	if err != nil {
		fmt.Println("Error executing the command:", err)
	}

	sh.Windows.PowerShell = false // Use cmd shell on Windows
	out, err := sh.Out("echo 'Hello, world!'")
	if err != nil {
		fmt.Println("Error executing the command:", err)
	} else {
		fmt.Println("Command output:", out)
	}
}
```

## Documentation for the "file" library in Golang

The `file` package provides functions for working with files in Go (Golang).

### Import

```go
import (
	"github.com/Tom5521/MyGolangTools/commands"
)
```

### Function `CheckFile(file string) (bool, error)`

The `CheckFile` function checks if a file exists at the provided location.

Parameters:
- `file` (string): Path to the file you want to check.

Returns:
- `bool`: `true` if the file exists, `false` if it doesn't.
- `error`: Error if there's an issue while checking the file's existence.

Usage example:

```go
exists, err := file.CheckFile("file.txt")
if err != nil {
    // Error handling
}
if exists {
    fmt.Println("The file exists.")
} else {
    fmt.Println("The file doesn't exist.")
}
```

### Function `ReadFileCont(file string) ([]byte, error)`

The `ReadFileCont` function reads the content of a file.

Parameters:
- `file` (string): Path to the file from which you want to read the content.

Returns:
- `[]byte`: Content of the file as bytes.
- `error`: Error if there's an issue while reading the file.

Usage example:

```go
content, err := file.ReadFileCont("file.txt")
if err != nil {
    // Error handling
}
fmt.Println(string(content))
```

### Function `ReWriteFile(file, text string) error`

The `ReWriteFile` function creates a new file or overwrites an existing file with the provided text.

Parameters:
- `file` (string): Path to the file that will be created or overwritten.
- `text` (string): Text to be written to the file.

Returns:
- `error`: Error if there's an issue while creating or writing to the file.

Usage example:

```go
err := file.ReWriteFile("new_file.txt", "File content")
if err != nil {
    // Error handling
}
```

### Function `GetBinaryDir() (string, error)`

The `GetBinaryDir` function retrieves the directory in which the binary executable is located.

Returns:
- `string`: Path to the executable's directory.
- `error`: Error if there's an issue while obtaining the executable's path.

Usage example:

```go
dir, err := file.GetBinaryDir()
if err != nil {
    // Error handling
}
fmt.Println("Executable directory:", dir)
```

